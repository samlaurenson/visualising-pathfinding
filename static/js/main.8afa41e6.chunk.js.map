{"version":3,"sources":["logo.svg","App.js","reportWebVitals.js","algorithms/astar.js","Grid.js","PathFinding.jsx","index.js","Nodes.js"],"names":["App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","nodeList","startNode","goalNode","boardHeight","boardWidth","a","calculateConnections","openList","path","gScore","fScore","i","push","Number","MAX_SAFE_INTEGER","id","currentNode","minFVal","forEach","node","finalPath","n","document","getElementById","className","length","splice","exploreConnections","undefined","connections","neighbour","gVal","heuristic","calculateHeuristic","includes","sleep","type","delay","Promise","resolve","setTimeout","nodes","height","width","x","y","curr","goal","current","coordinate","Math","floor","goalCoord","sqrt","this","AStar","Grid","gridArray","start","end","working","dragging","findNodeWithID","lookForID","r","prototype","init","createGrid","addEventListeners","gridHTML","row","rowHTML","c","nodeID","Node","innerHTML","loadPathfind","clearGrid","cell","onmousedown","e","preventDefault","onmousemove","onmouseleave","parseInt","onmouseup","window","console","log","PathFind","props","handleLoad","bind","startAlg","grid","addEventListener","onClick","React","Component","ReactDOM","render","StrictMode","module","exports"],"mappings":"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","file":"static/js/main.8afa41e6.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import logo from './logo.svg';\r\nimport './App.css';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <header className=\"App-header\">\r\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\r\n        <p>\r\n          Edit <code>src/App.js</code> and save to reload.\r\n        </p>\r\n        <a\r\n          className=\"App-link\"\r\n          href=\"https://reactjs.org\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        >\r\n          Learn React\r\n        </a>\r\n      </header>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","async function AStar(nodeList, startNode, goalNode, boardHeight, boardWidth) {\r\n    calculateConnections(nodeList, boardHeight, boardWidth);\r\n    let openList = [];\r\n    let path = [];\r\n\r\n    let gScore = [];\r\n    let fScore = [];\r\n\r\n    //Filling gScore, fScore and path arrays\r\n    for(let i = 0; i < boardHeight * boardWidth; ++i)\r\n    {\r\n        gScore.push(Number.MAX_SAFE_INTEGER);\r\n        fScore.push(0);\r\n        path.push(0);\r\n    }\r\n\r\n    openList.push(startNode);\r\n    gScore[startNode.id] = 0;\r\n    fScore[startNode.id] = 0;\r\n\r\n    while(openList.length !== 0)\r\n    {\r\n        let currentNode;\r\n        let minFVal = Number.MAX_SAFE_INTEGER;\r\n\r\n        openList.forEach(function(node) {\r\n            if(fScore[node.id] < minFVal)\r\n            {\r\n                minFVal = fScore[node.id];\r\n                currentNode = node;\r\n            }\r\n        });\r\n\r\n        if(currentNode === goalNode)\r\n        {\r\n            //Path has been found - draw the path\r\n            let finalPath = [];\r\n            let n = goalNode.id;\r\n            let cell;\r\n\r\n            while(n !== startNode.id)\r\n            {\r\n                finalPath.push(path[n]);\r\n                if(n !== goalNode.id)\r\n                {\r\n                    cell = document.getElementById(n);\r\n                    cell.className = 'path';\r\n                }\r\n                n = path[n];\r\n            }\r\n\r\n            \r\n            return \"Found!\";\r\n        }\r\n\r\n        for(let i = 0; i < openList.length; ++i)\r\n        {\r\n            if(openList[i].id === currentNode.id)\r\n            {\r\n                openList.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n\r\n        await exploreConnections(currentNode, gScore, fScore, goalNode, boardHeight, boardWidth, openList, path);\r\n    }\r\n    return undefined; //if goal was not found\r\n}\r\n\r\nasync function exploreConnections(currentNode, gScore, fScore, goalNode, boardHeight, boardWidth, openList, path)\r\n{\r\n    for(let i = 0; i < currentNode.connections.length; ++i)\r\n    {\r\n        let neighbour = currentNode.connections[i];\r\n\r\n        let gVal = gScore[currentNode.id] + 1; //Since this is a grid, will only need to increase distance by 1\r\n            \r\n        //If the distance travelled from current node to this neighbour node is less than the distance travelled already\r\n        //(If there is a shorter route, then follow this one)\r\n        if(gVal < gScore[neighbour.id])\r\n        {\r\n            path[neighbour.id] = currentNode.id; //Neighbour will know where it has come from by placing it's parent in the path array\r\n            gScore[neighbour.id] = gVal;\r\n            let heuristic = calculateHeuristic(neighbour.id, goalNode.id, boardHeight, boardWidth);\r\n            fScore[neighbour.id] = gVal + heuristic;\r\n\r\n            //If neighbour node is not in the open list - then it will be added\r\n            if(!openList.includes(neighbour))\r\n            {\r\n                await sleep(10 * i);\r\n                openList.push(neighbour);\r\n\r\n                //Making if statement to prevent goal node type being changed\r\n                if(neighbour.id !== goalNode.id)\r\n                {\r\n                    neighbour.type = 'open';\r\n                    let cell = document.getElementById(neighbour.id);\r\n                    cell.className = neighbour.type;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nconst sleep = (delay) => new Promise((resolve) => setTimeout(resolve, delay));\r\n\r\n//Function to get the neighbours/connections for each node\r\nfunction calculateConnections(nodes, height, width)\r\n{\r\n    //Nested for loop to get connections for every node in the grid\r\n    for(let x = 0; x < nodes.length; ++x)\r\n    {\r\n        for(let y = 0; y < nodes[x].length; ++y)\r\n        {\r\n            nodes[x][y].connections = []; //Clearing any existing conneciton for the node\r\n\r\n            //If selected node is a wall - then skip it\r\n            if(nodes[x][y].type === 'wall')\r\n            {\r\n                continue;\r\n            }\r\n\r\n            //If there is something above this node\r\n            if(x - 1 >= 0 && nodes[x-1][y].type !== 'wall')\r\n            {\r\n                nodes[x][y].connections.push(nodes[x-1][y]);\r\n            }\r\n\r\n            //there is a node below - add to connection\r\n            if(x + 1 < height && nodes[x+1][y].type !== 'wall')\r\n            {\r\n                nodes[x][y].connections.push(nodes[x+1][y]);\r\n            }\r\n\r\n            //there is a node to left - add to connection\r\n            if(y - 1 >= 0 && nodes[x][y-1].type !== 'wall')\r\n            {\r\n                nodes[x][y].connections.push(nodes[x][y-1]);\r\n            }\r\n\r\n            //there is a node to right - add to connection\r\n            if(y + 1 < width && nodes[x][y+1].type !== 'wall')\r\n            {\r\n                nodes[x][y].connections.push(nodes[x][y+1]);\r\n            }\r\n\r\n            //DIAGONALS\r\n\r\n            //TOP LEFT\r\n            //Checks if there is a wall in square it wants to go and wall directly above themself\r\n            if(x-1>=0 && y-1>=0 && nodes[x-1][y-1].type !== 'wall' && nodes[x-1][y].type !== 'wall')\r\n            {\r\n                nodes[x][y].connections.push(nodes[x-1][y-1]);\r\n            }\r\n\r\n            //TOP RIGHT\r\n            if(x-1>=0 && y+1 < width && nodes[x-1][y+1].type !== 'wall' && nodes[x-1][y].type !== 'wall')\r\n            {\r\n                nodes[x][y].connections.push(nodes[x-1][y+1]);\r\n            }\r\n\r\n            //BOTTOM LEFT\r\n            if(x+1 < height && y-1>=0 && nodes[x+1][y-1].type !== 'wall' && nodes[x+1][y].type !== 'wall')\r\n            {\r\n                nodes[x][y].connections.push(nodes[x+1][y-1]);\r\n            }\r\n\r\n            //BOTTOM RIGHT\r\n            if(x+1 < height && y+1 < width && nodes[x+1][y+1].type !== 'wall' && nodes[x+1][y].type !== 'wall')\r\n            {\r\n                nodes[x][y].connections.push(nodes[x+1][y+1]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction calculateHeuristic(curr, goal, height, width)\r\n{\r\n    let current = new coordinate(((curr % width)), Math.floor(curr/width));\r\n    let goalCoord = new coordinate(((goal % width)), Math.floor(goal/width));\r\n    return Math.sqrt((goalCoord.x - current.x)**2 + (goalCoord.y - current.y)**2);\r\n}\r\n\r\nfunction coordinate(x, y)\r\n{\r\n    this.x = x;\r\n    this.y = y;\r\n}\r\n\r\nexport default AStar;","import './stylesheet.css';\r\nimport Node from './Nodes';\r\nimport AStar from './algorithms/astar';\r\n\r\nfunction Grid(height, width) {\r\n    this.height = height;\r\n    this.width = width;\r\n    this.gridArray = [];\r\n    this.nodes = [];\r\n    this.start = undefined;\r\n    this.end = undefined;\r\n    this.working = false;\r\n    this.dragging = undefined; //Used to check if squares are currently being dragged\r\n    //this.algorithm = undefined;\r\n}\r\n\r\nGrid.prototype.init = function() {\r\n    this.createGrid();\r\n    this.addEventListeners();\r\n};\r\n\r\nGrid.prototype.createGrid = function() {\r\n    let gridHTML = \"\";\r\n\r\n    for(let r = 0; r < this.height; ++r)\r\n    {\r\n        let row = [];\r\n        let rowHTML = `<tr id=\"rowID ${r}\">`;\r\n        this.nodes.push([]);\r\n        for(let c = 0; c < this.width; ++c)\r\n        {\r\n            //Adding nodes to the grid\r\n            let nodeID = undefined;\r\n            if(r !== 0)\r\n            {\r\n                nodeID = (r * this.width) + c;\r\n            } else {\r\n                nodeID = c;\r\n            }\r\n\r\n            let node = undefined;\r\n            if(nodeID === 23)\r\n            {\r\n                node = new Node(nodeID, 'startPoint');\r\n                this.start = node;\r\n            } else if(nodeID === 120)\r\n            {\r\n                node = new Node(nodeID, 'endPoint');\r\n                this.end = node;\r\n            }\r\n            else {\r\n                node = new Node(nodeID, 'inactive');\r\n            }\r\n\r\n            row.push(node);\r\n            rowHTML += `<td id=\"${nodeID}\" class=\"${node.type}\"></td>`; //Adding the row to the HTML table\r\n            this.nodes[r].push(node);\r\n        }\r\n        this.gridArray.push(row);\r\n        gridHTML += rowHTML +  `</tr>`;\r\n    }\r\n    //get board element and set the board elements innerHTML to gridHTML\r\n    let grid = document.getElementById(\"board\");\r\n    grid.innerHTML = gridHTML;\r\n};\r\n\r\nGrid.prototype.loadPathfind = async function () {\r\n    //Probably a better way of doing this - but the grid has a property to store whether it is currently working on an algorithm\r\n    //If it is - then the reset button will not work until the algorithm has finished\r\n    //Once algorithm is finished then the \"working\" property will be set to false and the user can press the reset button\r\n    this.working = true;\r\n    await AStar(this.nodes, findNodeWithID(this.start.id, this.nodes), findNodeWithID(this.end.id, this.nodes), this.height, this.width);\r\n    this.working = false;\r\n};\r\n\r\n//Method to get rid of the yellow tiles (discovered path) and blue tiles (tiles in open list)\r\nGrid.prototype.clearGrid = function() {\r\n    if(this.working === true) { return; }\r\n    for(let r = 0; r < this.nodes.length; ++r)\r\n    {\r\n        for(let c = 0; c < this.nodes[r].length; ++c)\r\n        {\r\n            let cell = document.getElementById(this.nodes[r][c].id);\r\n            if(cell.className === 'path' || cell.className === 'open')\r\n            {\r\n                cell.className = 'inactive';\r\n                this.nodes[r][c].type = 'inactive';\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nGrid.prototype.addEventListeners = function() {\r\n    for(let r = 0; r < this.nodes.length; ++r)\r\n    {\r\n        for(let c = 0; c < this.nodes[r].length; ++c)\r\n        {\r\n            let cell = document.getElementById(this.nodes[r][c].id);\r\n\r\n            //When user clicks on an inactive square - will turn in to a wall\r\n            //if user clicks on a wall then the square will turn inactive\r\n            cell.onmousedown = (e) => {\r\n                e.preventDefault();\r\n                //If pathfinding algorithm is already in progress then don't allow mouse events\r\n                if(this.working) { return; }\r\n\r\n                if(cell.className === 'startPoint' || cell.className === 'endPoint') {\r\n                    //Set node to drag to the current start/end node \r\n                    this.dragging = this.nodes[r][c];\r\n\r\n                    //Setting the start/end to undefined (will be used to check if the user has dragged either start or end points off the grid)\r\n                    cell.className === 'startPoint' ? this.start = undefined : this.end = undefined;\r\n                    return; \r\n                }\r\n\r\n                this.dragging = 'wall'; //Allowing dragging to draw walls\r\n                cell.className = cell.className === 'inactive' ? 'wall' : 'inactive';\r\n                this.nodes[r][c].type = cell.className;\r\n            }\r\n\r\n            cell.onmousemove = (e) => {\r\n                if(this.dragging === undefined) { return; }\r\n                if(this.dragging === 'wall' && (cell.className === 'inactive' || cell.className === 'wall')) { this.nodes[r][c].type = 'wall'; cell.className = this.dragging; return; } //dragging to draw walls\r\n                if(this.dragging !== 'wall') { cell.className = this.dragging.type; } //If not drawing walls - do this\r\n            }\r\n\r\n            cell.onmouseleave = (e) => {\r\n                if(this.dragging === undefined || this.dragging === 'wall') { return; }\r\n                let node = findNodeWithID(parseInt(cell.id), this.nodes);\r\n                if(this.dragging.id === node.id) { cell.className = 'inactive'; return; } //Means a duplicate cell won't be left behind\r\n                cell.className = node.type;\r\n            }\r\n\r\n            cell.onmouseup = (e) => {\r\n                if(this.dragging === 'wall') { this.dragging = undefined; return; }\r\n                if(this.dragging === undefined) { return; }\r\n\r\n                //If user drags end point on top of start point - set end point back to where it came from and re-colour the nodes\r\n                if(('startPoint' === this.nodes[r][c].type && this.dragging.type === 'endPoint') || ('endPoint' === this.nodes[r][c].type && this.dragging.type === 'startPoint')) {\r\n                    this.dragging.type === 'startPoint' ? this.start = this.dragging : this.end = this.dragging;\r\n                    document.getElementById(this.start.id).className = this.start.type;\r\n                    document.getElementById(this.end.id).className = this.end.type;\r\n                    return;\r\n                }\r\n\r\n                //checks whether the user has clicked on the start/end point instead of dragging\r\n                if(this.dragging.id === parseInt(cell.id)) { \r\n                    this.dragging.type === 'startPoint' ? this.start = this.nodes[r][c] : this.end = this.nodes[r][c];\r\n                    this.dragging = undefined; \r\n                    return; \r\n                }\r\n\r\n                cell.className = this.dragging.type;\r\n                this.nodes[r][c].type = this.dragging.type;\r\n                this.dragging.type === 'startPoint' ? this.start = this.nodes[r][c] : this.end = this.nodes[r][c];\r\n                this.dragging.type = 'inactive'; //Making the old position of the node inactive\r\n                this.clearGrid(); \r\n                this.dragging = undefined;\r\n            }\r\n        }\r\n    }\r\n\r\n    //In case the user drags the start or end point off the grid\r\n    //they will be placed back in their default spots\r\n    window.onmouseup = (e) => {\r\n        console.log(\"up\");\r\n        this.dragging = undefined;\r\n        if(this.start === undefined)\r\n        {\r\n            this.clearGrid();\r\n            this.start = findNodeWithID(23, this.nodes);\r\n            this.start.type = 'startPoint';\r\n            document.getElementById(this.start.id).className = this.start.type;\r\n        }\r\n\r\n        if(this.end === undefined)\r\n        {\r\n            this.clearGrid();\r\n            this.end = findNodeWithID(120, this.nodes);\r\n            this.end.type = 'endPoint';\r\n            document.getElementById(this.end.id).className = this.end.type;\r\n        }\r\n    }\r\n};\r\n\r\n//This function will find the node with the ID no matter where it is on the grid\r\n//Unfortunately, this comes at a cost of greater time complexity than the \"getNodeByID\" function as it has to search every node\r\n//So if it would be possible to swap ID's when moved in the grid that could improve program speeds\r\n//But for now this will do. :)\r\nfunction findNodeWithID(lookForID, nodes)\r\n{\r\n    for(let r = 0; r < nodes.length; ++r)\r\n    {\r\n        for(let n = 0; n < nodes[r].length; ++n)\r\n        {\r\n            if(nodes[r][n].id === lookForID)\r\n            {\r\n                return nodes[r][n];\r\n            }\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction getNodeByID(nodeID, h, width, nodes)\r\n{\r\n    //Function that gets nodes by ID assuming they have not been moved on grid \r\n    let column = (nodeID % width); \r\n    let row = Math.floor(nodeID / width); //Assuming row starts at 0, otherwise (node.id/width) + 1\r\n    return nodes[row][column];\r\n}\r\n\r\nexport default  Grid;","import React from 'react';\r\nimport Grid from './Grid.js';\r\n\r\nclass PathFind extends React.Component {\r\n    constructor(props)\r\n    {\r\n        super(props);\r\n        this.handleLoad = this.handleLoad.bind(this);\r\n        this.startAlg = this.startAlg.bind(this);\r\n        this.clearGrid = this.clearGrid.bind(this);\r\n        this.grid = new Grid(15, 15);\r\n    }\r\n\r\n    componentDidMount() {\r\n        window.addEventListener('load', this.handleLoad);\r\n    }\r\n\r\n    handleLoad() {\r\n        this.grid.init();\r\n    }\r\n\r\n    startAlg() {\r\n        this.grid.clearGrid();\r\n        this.grid.loadPathfind();\r\n    }\r\n\r\n    clearGrid() {\r\n        this.grid.clearGrid();\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div id='grid'>\r\n                <button id=\"startPathing\" onClick={this.startAlg}>Start</button>\r\n                <button id=\"clear\" onClick={this.clearGrid}>Reset</button>\r\n                <table id='board'></table>\r\n            </div>\r\n        ); \r\n    }\r\n}\r\n\r\nexport default PathFind;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport PathFind from './PathFinding';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <PathFind/>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n","function Node(id, type) {\r\n    this.id = id;\r\n    this.type = type;\r\n    this.connections = [];\r\n}\r\n\r\nmodule.exports = Node;"],"sourceRoot":""}