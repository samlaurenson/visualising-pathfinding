{"version":3,"sources":["logo.svg","App.js","reportWebVitals.js","algorithms/astar.js","Grid.js","PathFinding.jsx","Legends.jsx","index.js","Nodes.js"],"names":["App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","nodeList","startNode","goalNode","boardHeight","boardWidth","a","calculateConnections","openList","path","gScore","fScore","i","push","Number","MAX_SAFE_INTEGER","id","currentNode","minFVal","forEach","node","finalPath","n","document","getElementById","className","length","splice","exploreConnections","undefined","connections","neighbour","gVal","cost","heuristic","calculateHeuristic","includes","sleep","type","delay","Promise","resolve","setTimeout","nodes","height","width","x","y","connection","curr","goal","current","coordinate","Math","floor","goalCoord","sqrt","this","AStar","Grid","gridArray","start","end","working","dragging","findNodeWithID","lookForID","r","prototype","init","createGrid","addEventListeners","gridHTML","row","rowHTML","c","nodeID","Node","innerHTML","loadPathfind","clearGrid","clearWalls","cell","onmousedown","e","preventDefault","onmousemove","onmouseleave","parseInt","onmouseup","window","console","log","PathFind","props","handleLoad","bind","startAlg","grid","addEventListener","onClick","React","Component","Legends","class","ReactDOM","render","StrictMode","module","exports"],"mappings":"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","file":"static/js/main.1772b76c.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import logo from './logo.svg';\r\nimport './App.css';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <header className=\"App-header\">\r\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\r\n        <p>\r\n          Edit <code>src/App.js</code> and save to reload.\r\n        </p>\r\n        <a\r\n          className=\"App-link\"\r\n          href=\"https://reactjs.org\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        >\r\n          Learn React\r\n        </a>\r\n      </header>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","async function AStar(nodeList, startNode, goalNode, boardHeight, boardWidth) {\r\n    calculateConnections(nodeList, boardHeight, boardWidth);\r\n    let openList = [];\r\n    let path = [];\r\n\r\n    let gScore = [];\r\n    let fScore = [];\r\n\r\n    //Filling gScore, fScore and path arrays\r\n    for(let i = 0; i < boardHeight * boardWidth; ++i)\r\n    {\r\n        gScore.push(Number.MAX_SAFE_INTEGER);\r\n        fScore.push(0);\r\n        path.push(0);\r\n    }\r\n\r\n    openList.push(startNode);\r\n    gScore[startNode.id] = 0;\r\n    fScore[startNode.id] = 0;\r\n\r\n    while(openList.length !== 0)\r\n    {\r\n        let currentNode;\r\n        let minFVal = Number.MAX_SAFE_INTEGER;\r\n\r\n        openList.forEach(function(node) {\r\n            if(fScore[node.id] < minFVal)\r\n            {\r\n                minFVal = fScore[node.id];\r\n                currentNode = node;\r\n            }\r\n        });\r\n\r\n        if(currentNode === goalNode)\r\n        {\r\n            //Path has been found - draw the path\r\n            let finalPath = [];\r\n            let n = goalNode.id;\r\n            let cell;\r\n\r\n            while(n !== startNode.id)\r\n            {\r\n                finalPath.push(path[n]);\r\n                if(n !== goalNode.id)\r\n                {\r\n                    cell = document.getElementById(n);\r\n                    cell.className = 'path';\r\n                }\r\n                n = path[n];\r\n            }\r\n\r\n            \r\n            return \"Found!\";\r\n        }\r\n\r\n        for(let i = 0; i < openList.length; ++i)\r\n        {\r\n            if(openList[i].id === currentNode.id)\r\n            {\r\n                openList.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n\r\n        //If statement to colour the visited nodes in blue to show the nodes\r\n        //the algorithm has accessed\r\n        if(currentNode !== startNode)\r\n        {\r\n            let cell = document.getElementById(currentNode.id);\r\n            cell.className = 'visited';\r\n        }\r\n\r\n        await exploreConnections(currentNode, gScore, fScore, goalNode, boardHeight, boardWidth, openList, path);\r\n    }\r\n    return undefined; //if goal was not found\r\n}\r\n\r\nasync function exploreConnections(currentNode, gScore, fScore, goalNode, boardHeight, boardWidth, openList, path)\r\n{\r\n    for(let i = 0; i < currentNode.connections.length; ++i)\r\n    {\r\n        let neighbour = currentNode.connections[i].node;\r\n\r\n        let gVal = gScore[currentNode.id] + currentNode.connections[i].cost; //Since this is a grid, will only need to increase distance by 1\r\n            \r\n        //If the distance travelled from current node to this neighbour node is less than the distance travelled already\r\n        //(If there is a shorter route, then follow this one)\r\n        if(gVal < gScore[neighbour.id])\r\n        {\r\n            path[neighbour.id] = currentNode.id; //Neighbour will know where it has come from by placing it's parent in the path array\r\n            gScore[neighbour.id] = gVal;\r\n            let heuristic = calculateHeuristic(neighbour.id, goalNode.id, boardHeight, boardWidth);\r\n            fScore[neighbour.id] = gVal + heuristic;\r\n\r\n            //If neighbour node is not in the open list - then it will be added\r\n            if(!openList.includes(neighbour))\r\n            {\r\n                await sleep(10 * i);\r\n                openList.push(neighbour);\r\n\r\n                //Making if statement to prevent goal node type being changed\r\n                if(neighbour.id !== goalNode.id)\r\n                {\r\n                    neighbour.type = 'open';\r\n                    let cell = document.getElementById(neighbour.id);\r\n                    cell.className = neighbour.type;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nconst sleep = (delay) => new Promise((resolve) => setTimeout(resolve, delay));\r\n\r\n//Function to get the neighbours/connections for each node\r\nfunction calculateConnections(nodes, height, width)\r\n{\r\n    //Nested for loop to get connections for every node in the grid\r\n    for(let x = 0; x < nodes.length; ++x)\r\n    {\r\n        for(let y = 0; y < nodes[x].length; ++y)\r\n        {\r\n            nodes[x][y].connections = []; //Clearing any existing conneciton for the node\r\n\r\n            //If selected node is a wall - then skip it\r\n            if(nodes[x][y].type === 'wall')\r\n            {\r\n                continue;\r\n            }\r\n\r\n            //If there is something above this node\r\n            if(x - 1 >= 0 && nodes[x-1][y].type !== 'wall')\r\n            {\r\n                nodes[x][y].connections.push(new connection(nodes[x-1][y], 1));\r\n            }\r\n\r\n            //there is a node below - add to connection\r\n            if(x + 1 < height && nodes[x+1][y].type !== 'wall')\r\n            {\r\n                nodes[x][y].connections.push(new connection(nodes[x+1][y], 1));\r\n            }\r\n\r\n            //there is a node to left - add to connection\r\n            if(y - 1 >= 0 && nodes[x][y-1].type !== 'wall')\r\n            {\r\n                nodes[x][y].connections.push(new connection(nodes[x][y-1], 1));\r\n            }\r\n\r\n            //there is a node to right - add to connection\r\n            if(y + 1 < width && nodes[x][y+1].type !== 'wall')\r\n            {\r\n                nodes[x][y].connections.push(new connection(nodes[x][y+1], 1));\r\n            }\r\n\r\n            //DIAGONALS\r\n\r\n            //TOP LEFT\r\n            //Checks if there is a wall in square it wants to go and wall directly above themself\r\n            if(x-1>=0 && y-1>=0 && nodes[x-1][y-1].type !== 'wall' && nodes[x-1][y].type !== 'wall')\r\n            {\r\n                nodes[x][y].connections.push(new connection(nodes[x-1][y-1], 1.05));\r\n            }\r\n\r\n            //TOP RIGHT\r\n            if(x-1>=0 && y+1 < width && nodes[x-1][y+1].type !== 'wall' && nodes[x-1][y].type !== 'wall')\r\n            {\r\n                nodes[x][y].connections.push(new connection(nodes[x-1][y+1], 1.05));\r\n            }\r\n\r\n            //BOTTOM LEFT\r\n            if(x+1 < height && y-1>=0 && nodes[x+1][y-1].type !== 'wall' && nodes[x+1][y].type !== 'wall')\r\n            {\r\n                nodes[x][y].connections.push(new connection(nodes[x+1][y-1], 1.05));\r\n            }\r\n\r\n            //BOTTOM RIGHT\r\n            if(x+1 < height && y+1 < width && nodes[x+1][y+1].type !== 'wall' && nodes[x+1][y].type !== 'wall')\r\n            {\r\n                nodes[x][y].connections.push(new connection(nodes[x+1][y+1], 1.05));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction calculateHeuristic(curr, goal, height, width)\r\n{\r\n    let current = new coordinate(((curr % width)), Math.floor(curr/width));\r\n    let goalCoord = new coordinate(((goal % width)), Math.floor(goal/width));\r\n    return Math.sqrt((goalCoord.x - current.x)**2 + (goalCoord.y - current.y)**2);\r\n}\r\n\r\nfunction coordinate(x, y)\r\n{\r\n    this.x = x;\r\n    this.y = y;\r\n}\r\n\r\n//Function to group the neighbour node and the cost to move to that node\r\n//Adjacent squares will cost 1 and diagonal squares will cost 1.05\r\n//1.05 for diagonal movements allows for the algorithm to still work fast and makes the path a more sensible route than\r\n//having the path zig zag all over the place but still be the same distance as going straight\r\nfunction connection(node, cost)\r\n{\r\n    this.node = node;\r\n    this.cost = cost;\r\n}\r\n\r\nexport default AStar;","import './stylesheet.css';\r\nimport Node from './Nodes';\r\nimport AStar from './algorithms/astar';\r\n\r\nfunction Grid(height, width) {\r\n    this.height = height;\r\n    this.width = width;\r\n    this.gridArray = [];\r\n    this.nodes = [];\r\n    this.start = undefined;\r\n    this.end = undefined;\r\n    this.working = false;\r\n    this.dragging = undefined; //Used to check if squares are currently being dragged\r\n    //this.algorithm = undefined;\r\n}\r\n\r\nGrid.prototype.init = function() {\r\n    this.createGrid();\r\n    this.addEventListeners();\r\n};\r\n\r\nGrid.prototype.createGrid = function() {\r\n    let gridHTML = \"\";\r\n\r\n    for(let r = 0; r < this.height; ++r)\r\n    {\r\n        let row = [];\r\n        let rowHTML = `<tr id=\"rowID ${r}\">`;\r\n        this.nodes.push([]);\r\n        for(let c = 0; c < this.width; ++c)\r\n        {\r\n            //Adding nodes to the grid\r\n            let nodeID = undefined;\r\n            if(r !== 0)\r\n            {\r\n                nodeID = (r * this.width) + c;\r\n            } else {\r\n                nodeID = c;\r\n            }\r\n\r\n            let node = undefined;\r\n            if(nodeID === 23)\r\n            {\r\n                node = new Node(nodeID, 'startPoint');\r\n                this.start = node;\r\n            } else if(nodeID === 120)\r\n            {\r\n                node = new Node(nodeID, 'endPoint');\r\n                this.end = node;\r\n            }\r\n            else {\r\n                node = new Node(nodeID, 'inactive');\r\n            }\r\n\r\n            row.push(node);\r\n            rowHTML += `<td id=\"${nodeID}\" class=\"${node.type}\"></td>`; //Adding the row to the HTML table\r\n            this.nodes[r].push(node);\r\n        }\r\n        this.gridArray.push(row);\r\n        gridHTML += rowHTML +  `</tr>`;\r\n    }\r\n    //get board element and set the board elements innerHTML to gridHTML\r\n    let grid = document.getElementById(\"board\");\r\n    grid.innerHTML = gridHTML;\r\n};\r\n\r\nGrid.prototype.loadPathfind = async function () {\r\n    if(this.working) { return; }\r\n\r\n    //Probably a better way of doing this - but the grid has a property to store whether it is currently working on an algorithm\r\n    //If it is - then the reset button will not work until the algorithm has finished\r\n    //Once algorithm is finished then the \"working\" property will be set to false and the user can press the reset button\r\n    this.working = true;\r\n    await AStar(this.nodes, findNodeWithID(this.start.id, this.nodes), findNodeWithID(this.end.id, this.nodes), this.height, this.width);\r\n    this.working = false;\r\n};\r\n\r\n//Method to get rid of the yellow tiles (discovered path) and blue tiles (tiles in open list)\r\nGrid.prototype.clearGrid = function(clearWalls) {\r\n    if(this.working === true) { return; }\r\n    for(let r = 0; r < this.nodes.length; ++r)\r\n    {\r\n        for(let c = 0; c < this.nodes[r].length; ++c)\r\n        {\r\n            let cell = document.getElementById(this.nodes[r][c].id);\r\n            if(cell.className === 'path' \r\n            || cell.className === 'open' \r\n            || cell.className === 'visited' \r\n            || (clearWalls && cell.className === 'wall'))\r\n            {\r\n                cell.className = 'inactive';\r\n                this.nodes[r][c].type = 'inactive';\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nGrid.prototype.addEventListeners = function() {\r\n    for(let r = 0; r < this.nodes.length; ++r)\r\n    {\r\n        for(let c = 0; c < this.nodes[r].length; ++c)\r\n        {\r\n            let cell = document.getElementById(this.nodes[r][c].id);\r\n\r\n            //When user clicks on an inactive square - will turn in to a wall\r\n            //if user clicks on a wall then the square will turn inactive\r\n            cell.onmousedown = (e) => {\r\n                e.preventDefault();\r\n                //If pathfinding algorithm is already in progress then don't allow mouse events\r\n                if(this.working) { return; }\r\n\r\n                if(cell.className === 'startPoint' || cell.className === 'endPoint') {\r\n                    //Set node to drag to the current start/end node \r\n                    this.dragging = this.nodes[r][c];\r\n\r\n                    //Setting the start/end to undefined (will be used to check if the user has dragged either start or end points off the grid)\r\n                    cell.className === 'startPoint' ? this.start = undefined : this.end = undefined;\r\n                    return; \r\n                }\r\n\r\n                this.dragging = 'wall'; //Allowing dragging to draw walls\r\n                cell.className = cell.className === 'inactive' ? 'wall' : 'inactive';\r\n                this.nodes[r][c].type = cell.className;\r\n            }\r\n\r\n            cell.onmousemove = (e) => {\r\n                if(this.dragging === undefined) { return; }\r\n                if(this.dragging === 'wall' && (cell.className === 'inactive' || cell.className === 'wall')) { this.nodes[r][c].type = 'wall'; cell.className = this.dragging; return; } //dragging to draw walls\r\n                if(this.dragging !== 'wall') { cell.className = this.dragging.type; } //If not drawing walls - do this\r\n            }\r\n\r\n            cell.onmouseleave = (e) => {\r\n                if(this.dragging === undefined || this.dragging === 'wall') { return; }\r\n                let node = findNodeWithID(parseInt(cell.id), this.nodes);\r\n                if(this.dragging.id === node.id) { cell.className = 'inactive'; return; } //Means a duplicate cell won't be left behind\r\n                cell.className = node.type;\r\n            }\r\n\r\n            cell.onmouseup = (e) => {\r\n                if(this.dragging === 'wall') { this.dragging = undefined; return; }\r\n                if(this.dragging === undefined) { return; }\r\n\r\n                //If user drags end point on top of start point - set end point back to where it came from and re-colour the nodes\r\n                if(('startPoint' === this.nodes[r][c].type && this.dragging.type === 'endPoint') || ('endPoint' === this.nodes[r][c].type && this.dragging.type === 'startPoint')) {\r\n                    this.dragging.type === 'startPoint' ? this.start = this.dragging : this.end = this.dragging;\r\n                    document.getElementById(this.start.id).className = this.start.type;\r\n                    document.getElementById(this.end.id).className = this.end.type;\r\n                    return;\r\n                }\r\n\r\n                //checks whether the user has clicked on the start/end point instead of dragging\r\n                if(this.dragging.id === parseInt(cell.id)) { \r\n                    this.dragging.type === 'startPoint' ? this.start = this.nodes[r][c] : this.end = this.nodes[r][c];\r\n                    this.dragging = undefined; \r\n                    return; \r\n                }\r\n\r\n                cell.className = this.dragging.type;\r\n                this.nodes[r][c].type = this.dragging.type;\r\n                this.dragging.type === 'startPoint' ? this.start = this.nodes[r][c] : this.end = this.nodes[r][c];\r\n                this.dragging.type = 'inactive'; //Making the old position of the node inactive\r\n                this.clearGrid(false); \r\n                this.dragging = undefined;\r\n            }\r\n        }\r\n    }\r\n\r\n    //In case the user drags the start or end point off the grid\r\n    //they will be placed back in their default spots\r\n    window.onmouseup = (e) => {\r\n        console.log(\"up\");\r\n        this.dragging = undefined;\r\n        if(this.start === undefined)\r\n        {\r\n            this.clearGrid(false);\r\n            this.start = findNodeWithID(23, this.nodes);\r\n            this.start.type = 'startPoint';\r\n            document.getElementById(this.start.id).className = this.start.type;\r\n        }\r\n\r\n        if(this.end === undefined)\r\n        {\r\n            this.clearGrid(false);\r\n            this.end = findNodeWithID(120, this.nodes);\r\n            this.end.type = 'endPoint';\r\n            document.getElementById(this.end.id).className = this.end.type;\r\n        }\r\n    }\r\n};\r\n\r\n//This function will find the node with the ID no matter where it is on the grid\r\n//Unfortunately, this comes at a cost of greater time complexity than the \"getNodeByID\" function as it has to search every node\r\n//So if it would be possible to swap ID's when moved in the grid that could improve program speeds\r\n//But for now this will do. :)\r\nfunction findNodeWithID(lookForID, nodes)\r\n{\r\n    for(let r = 0; r < nodes.length; ++r)\r\n    {\r\n        for(let n = 0; n < nodes[r].length; ++n)\r\n        {\r\n            if(nodes[r][n].id === lookForID)\r\n            {\r\n                return nodes[r][n];\r\n            }\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction getNodeByID(nodeID, h, width, nodes)\r\n{\r\n    //Function that gets nodes by ID assuming they have not been moved on grid \r\n    let column = (nodeID % width); \r\n    let row = Math.floor(nodeID / width); //Assuming row starts at 0, otherwise (node.id/width) + 1\r\n    return nodes[row][column];\r\n}\r\n\r\nexport default  Grid;","import React from 'react';\r\nimport Grid from './Grid.js';\r\n\r\nclass PathFind extends React.Component {\r\n    constructor(props)\r\n    {\r\n        super(props);\r\n        this.handleLoad = this.handleLoad.bind(this);\r\n        this.startAlg = this.startAlg.bind(this);\r\n        this.clearGrid = this.clearGrid.bind(this);\r\n        this.clearWalls = this.clearWalls.bind(this);\r\n        this.grid = new Grid(15, 15);\r\n    }\r\n\r\n    componentDidMount() {\r\n        window.addEventListener('load', this.handleLoad);\r\n    }\r\n\r\n    handleLoad() {\r\n        this.grid.init();\r\n    }\r\n\r\n    startAlg() {\r\n        this.grid.clearGrid();\r\n        this.grid.loadPathfind();\r\n    }\r\n\r\n    clearGrid() {\r\n        this.grid.clearGrid(false);\r\n    }\r\n\r\n    clearWalls() {\r\n        this.grid.clearGrid(true);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div id='grid'>\r\n                <button id=\"startPathing\" onClick={this.startAlg}>Start</button>\r\n                <button id=\"clear\" onClick={this.clearGrid}>Reset</button>\r\n                <button id=\"clearWalls\" onClick={this.clearWalls}>Clear Walls</button>\r\n                <table id='board'></table>\r\n            </div>\r\n        ); \r\n    }\r\n}\r\n\r\nexport default PathFind;\r\n","import React from 'react';\r\nimport './stylesheet.css';\r\n\r\nclass Legends extends React.Component {\r\n    render() {\r\n        return(\r\n        <div class='leg-bar'>\r\n            <ul>\r\n                <li id='legend'>\r\n                    <div id='icon' class='startLegend'></div>\r\n                    Start Node\r\n                </li>\r\n                <li id='legend'>\r\n                    <div id='icon' class='goalLegend'></div>\r\n                    Goal Node\r\n                </li>\r\n                <li id='legend'>\r\n                    <div id='icon' class='openLegend'></div>\r\n                    Open Node\r\n                </li>\r\n                <li id='legend'>\r\n                    <div id='icon' class='visitedLegend'></div>\r\n                    Visited Node\r\n                </li>\r\n                <li id='legend'>\r\n                    <div id='icon' class='pathLegend'></div>\r\n                    Path Node\r\n                </li>\r\n                <li id='legend'>\r\n                    <div id='icon' class='wallLegend'></div>\r\n                    Wall Node\r\n                </li>\r\n            </ul>\r\n        </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Legends;","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport PathFind from './PathFinding';\r\nimport Legends from './Legends';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <Legends/>\r\n    <PathFind/>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n","function Node(id, type) {\r\n    this.id = id;\r\n    this.type = type;\r\n    this.connections = [];\r\n}\r\n\r\nmodule.exports = Node;"],"sourceRoot":""}